// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package puffin_test

import (
	"bytes"
	"context"
	"os"
	"testing"

	"github.com/apache/iceberg-go/puffin"
	"github.com/apache/iceberg-go/table"
	"github.com/stretchr/testify/require"
)

// TestReadJavaEmptyPuffin reads an empty Puffin file generated by Java.
func TestReadJavaEmptyPuffin(t *testing.T) {
	data, err := os.ReadFile("testdata/empty.puffin")
	require.NoError(t, err)

	reader, err := puffin.NewPuffinReader(bytes.NewReader(data), int64(len(data)))
	require.NoError(t, err)

	footer, err := reader.ReadFooter()
	require.NoError(t, err)

	require.Empty(t, footer.Blobs)
	require.Equal(t, "Java TestDVPuffinInterop", footer.Properties[puffin.CreatedBy])
}

// TestReadJavaSparseDV reads a Puffin file with sparse deletion vector (rows 0, 5, 10, 100, 1000).
func TestReadJavaSparseDV(t *testing.T) {
	data, err := os.ReadFile("testdata/sparse-dv.puffin")
	require.NoError(t, err)

	reader, err := puffin.NewPuffinReader(bytes.NewReader(data), int64(len(data)))
	require.NoError(t, err)

	footer, err := reader.ReadFooter()
	require.NoError(t, err)

	// Verify footer properties
	require.Equal(t, "Java TestDVPuffinInterop", footer.Properties[puffin.CreatedBy])
	require.Equal(t, "sparse-dv", footer.Properties["test-type"])

	// Verify blob metadata
	require.Len(t, footer.Blobs, 1)
	blob := footer.Blobs[0]
	require.Equal(t, puffin.DeletionVectorV1, blob.Type)
	require.Equal(t, int64(-1), blob.SnapshotID)
	require.Equal(t, int64(-1), blob.SequenceNumber)
	require.Empty(t, blob.Fields)
	require.Equal(t, "s3://bucket/data/part-00001.parquet", blob.Properties["referenced-data-file"])

	// Read blob data (the serialized DV)
	dvData, err := reader.ReadBlob(blob)
	require.NoError(t, err)
	require.Equal(t, int(blob.Length), len(dvData))

	// Verify DV size matches what Java reported (50 bytes)
	require.Equal(t, 50, len(dvData))

	t.Logf("Sparse DV blob: offset=%d, length=%d", blob.Offset, blob.Length)
	t.Logf("DV data (first 20 bytes): %x", dvData[:min(20, len(dvData))])

	// Parse the DV and verify deleted positions
	// expectedCardinality = 5 (rows 0, 5, 10, 100, 1000)
	dvIndex, err := table.DeserializeDVPayload(dvData, 5)
	require.NoError(t, err)
	require.NoError(t, dvIndex.Load(context.Background()))

	// Verify deleted positions
	deletedPositions := []int64{0, 5, 10, 100, 1000}
	for _, pos := range deletedPositions {
		require.True(t, dvIndex.Contains(pos), "Position %d should be deleted", pos)
	}

	// Verify non-deleted positions
	notDeletedPositions := []int64{1, 2, 3, 4, 6, 7, 8, 9, 11, 50, 99, 101, 999, 1001}
	for _, pos := range notDeletedPositions {
		require.False(t, dvIndex.Contains(pos), "Position %d should NOT be deleted", pos)
	}

	t.Log("✓ All deleted positions verified correctly!")
}

// TestReadJavaRangeDV reads a Puffin file with range deletion vector (rows 0-99).
func TestReadJavaRangeDV(t *testing.T) {
	data, err := os.ReadFile("testdata/range-dv.puffin")
	require.NoError(t, err)

	reader, err := puffin.NewPuffinReader(bytes.NewReader(data), int64(len(data)))
	require.NoError(t, err)

	footer, err := reader.ReadFooter()
	require.NoError(t, err)

	// Verify footer properties
	require.Equal(t, "Java TestDVPuffinInterop", footer.Properties[puffin.CreatedBy])
	require.Equal(t, "range-dv", footer.Properties["test-type"])

	// Verify blob metadata
	require.Len(t, footer.Blobs, 1)
	blob := footer.Blobs[0]
	require.Equal(t, puffin.DeletionVectorV1, blob.Type)
	require.Equal(t, int64(100), blob.SnapshotID)
	require.Equal(t, int64(1), blob.SequenceNumber)

	// Read blob data
	dvData, err := reader.ReadBlob(blob)
	require.NoError(t, err)

	// Verify DV size matches what Java reported (39 bytes)
	require.Equal(t, 39, len(dvData))

	t.Logf("Range DV blob: offset=%d, length=%d", blob.Offset, blob.Length)

	// Parse the DV and verify deleted positions
	// expectedCardinality = 100 (rows 0-99)
	dvIndex, err := table.DeserializeDVPayload(dvData, 100)
	require.NoError(t, err)
	require.NoError(t, dvIndex.Load(context.Background()))

	// Verify all positions 0-99 are deleted
	for pos := int64(0); pos < 100; pos++ {
		require.True(t, dvIndex.Contains(pos), "Position %d should be deleted", pos)
	}

	// Verify positions 100+ are NOT deleted
	for pos := int64(100); pos < 110; pos++ {
		require.False(t, dvIndex.Contains(pos), "Position %d should NOT be deleted", pos)
	}

	t.Log("✓ All 100 deleted positions verified correctly!")
}

// TestReadJavaMultipleDVs reads a Puffin file with multiple deletion vectors.
func TestReadJavaMultipleDVs(t *testing.T) {
	data, err := os.ReadFile("testdata/multiple-dvs.puffin")
	require.NoError(t, err)

	reader, err := puffin.NewPuffinReader(bytes.NewReader(data), int64(len(data)))
	require.NoError(t, err)

	footer, err := reader.ReadFooter()
	require.NoError(t, err)

	// Verify footer properties
	require.Equal(t, "Java TestDVPuffinInterop", footer.Properties[puffin.CreatedBy])
	require.Equal(t, "multiple-dvs", footer.Properties["test-type"])

	// Verify we have 2 blobs
	require.Len(t, footer.Blobs, 2)

	// Verify first blob (sparse: 0, 10, 20)
	blob1 := footer.Blobs[0]
	require.Equal(t, puffin.DeletionVectorV1, blob1.Type)
	require.Equal(t, "file1.parquet", blob1.Properties["referenced-data-file"])

	// Verify second blob (range: 50-59)
	blob2 := footer.Blobs[1]
	require.Equal(t, puffin.DeletionVectorV1, blob2.Type)
	require.Equal(t, "file2.parquet", blob2.Properties["referenced-data-file"])

	// Read both blobs
	dv1Data, err := reader.ReadBlob(blob1)
	require.NoError(t, err)

	dv2Data, err := reader.ReadBlob(blob2)
	require.NoError(t, err)

	t.Logf("DV1: offset=%d, length=%d, data_len=%d", blob1.Offset, blob1.Length, len(dv1Data))
	t.Logf("DV2: offset=%d, length=%d, data_len=%d", blob2.Offset, blob2.Length, len(dv2Data))

	// Verify blobs don't overlap
	require.True(t, blob1.Offset+blob1.Length <= blob2.Offset,
		"Blobs should not overlap: blob1 ends at %d, blob2 starts at %d",
		blob1.Offset+blob1.Length, blob2.Offset)

	// Parse DV1 and verify (rows 0, 10, 20)
	dv1Index, err := table.DeserializeDVPayload(dv1Data, 3)
	require.NoError(t, err)
	require.NoError(t, dv1Index.Load(context.Background()))

	require.True(t, dv1Index.Contains(0), "DV1: Position 0 should be deleted")
	require.True(t, dv1Index.Contains(10), "DV1: Position 10 should be deleted")
	require.True(t, dv1Index.Contains(20), "DV1: Position 20 should be deleted")
	require.False(t, dv1Index.Contains(5), "DV1: Position 5 should NOT be deleted")
	require.False(t, dv1Index.Contains(50), "DV1: Position 50 should NOT be deleted")

	// Parse DV2 and verify (rows 50-59)
	dv2Index, err := table.DeserializeDVPayload(dv2Data, 10)
	require.NoError(t, err)
	require.NoError(t, dv2Index.Load(context.Background()))

	for pos := int64(50); pos < 60; pos++ {
		require.True(t, dv2Index.Contains(pos), "DV2: Position %d should be deleted", pos)
	}
	require.False(t, dv2Index.Contains(0), "DV2: Position 0 should NOT be deleted")
	require.False(t, dv2Index.Contains(49), "DV2: Position 49 should NOT be deleted")
	require.False(t, dv2Index.Contains(60), "DV2: Position 60 should NOT be deleted")

	t.Log("✓ Both DVs parsed and verified correctly!")
}

// TestReadAllJavaPuffinFiles reads all Java-generated Puffin files.
func TestReadAllJavaPuffinFiles(t *testing.T) {
	files := []struct {
		name      string
		blobCount int
	}{
		{"testdata/empty.puffin", 0},
		{"testdata/sparse-dv.puffin", 1},
		{"testdata/range-dv.puffin", 1},
		{"testdata/multiple-dvs.puffin", 2},
	}

	for _, f := range files {
		t.Run(f.name, func(t *testing.T) {
			data, err := os.ReadFile(f.name)
			require.NoError(t, err)

			reader, err := puffin.NewPuffinReader(bytes.NewReader(data), int64(len(data)))
			require.NoError(t, err)

			footer, err := reader.ReadFooter()
			require.NoError(t, err)

			require.Len(t, footer.Blobs, f.blobCount)
			require.Equal(t, "Java TestDVPuffinInterop", footer.Properties[puffin.CreatedBy])

			// Read all blobs
			for i, blob := range footer.Blobs {
				blobData, err := reader.ReadBlob(blob)
				require.NoError(t, err)
				require.Equal(t, int(blob.Length), len(blobData))
				t.Logf("Blob %d: type=%s, offset=%d, length=%d", i, blob.Type, blob.Offset, blob.Length)
			}
		})
	}
}
